// oracle-property-graph-import.js - Importiert Memgraph-Daten in Oracle Native Property Graph
const fs = require('fs').promises;
const oracledb = require('oracledb');
const { initializeOraclePool, getOracleConnection, closeOraclePool } = require('./src/config/database');

// Parser für Cypher CREATE Statements
function parseCypherCreate(line) {
    // Node parsen
    const nodeMatch = line.match(/CREATE\s+\(:__mg_vertex__:`(\w+)`\s+({[^}]+})\);/);
    if (nodeMatch) {
        const label = nodeMatch[1];
        const propsStr = nodeMatch[2];

        const props = {};
        let mgId = null;

        const propRegex = /`?([^`:\s]+)`?\s*:\s*("(?:[^"\\]|\\.)*"|[^,}]+)/g;
        let match;
        while ((match = propRegex.exec(propsStr)) !== null) {
            let key = match[1];
            let value = match[2];

            if (key === '__mg_id__') {
                mgId = parseInt(value);
                continue;
            }

            if (key === ':LABEL') key = 'label';

            if (value.startsWith('"') && value.endsWith('"')) {
                value = value.slice(1, -1).replace(/\\'/g, "'").replace(/\\"/g, '"');
            }

            props[key] = value;
        }

        return { type: 'node', label, properties: props, mgId };
    }

    // Relationship parsen
    const relMatch = line.match(/MATCH.*WHERE\s+u\.__mg_id__\s*=\s*(\d+)\s+AND\s+v\.__mg_id__\s*=\s*(\d+)\s+CREATE\s+\(u\)-\[:`(\w+)`(?:\s+({[^}]+}))?\]->\(v\);/);
    if (relMatch) {
        return {
            type: 'relationship',
            fromMgId: parseInt(relMatch[1]),
            toMgId: parseInt(relMatch[2]),
            relType: relMatch[3],
            properties: {}
        };
    }

    return null;
}

async function importToOraclePropertyGraph(filename) {
    console.log('🌐 Oracle Native Property Graph Import');
    console.log('=====================================\n');

    let connection;
    const mgIdMapping = {}; // Memgraph ID zu Oracle ID Mapping

    try {
        // Datei lesen und parsen
        console.log(`📖 Lese Datei: ${filename}`);
        const content = await fs.readFile(filename, 'utf8');
        const lines = content.split('\n').filter(line => line.trim());

        const nodes = [];
        const relationships = [];

        for (const line of lines) {
            if (line.startsWith('CREATE (:')) {
                const parsed = parseCypherCreate(line);
                if (parsed?.type === 'node') nodes.push(parsed);
            } else if (line.startsWith('MATCH')) {
                const parsed = parseCypherCreate(line);
                if (parsed?.type === 'relationship') relationships.push(parsed);
            }
        }

        console.log(`✅ Gefunden: ${nodes.length} Vertices, ${relationships.length} Edges\n`);

        await initializeOraclePool();
        connection = await getOracleConnection();

        // 1. Erstelle Basis-Tabellen für Property Graph
        console.log('📋 Erstelle Vertex und Edge Tabellen...\n');

        // Vertex Tabelle
        try {
            await connection.execute(`DROP TABLE kg_vertices CASCADE CONSTRAINTS`);
        } catch (e) {}

        await connection.execute(`
      CREATE TABLE kg_vertices (
        vertex_id VARCHAR2(50) PRIMARY KEY,
        vertex_type VARCHAR2(50) NOT NULL,
        properties CLOB,
        CHECK (properties IS JSON)
      )
    `);

        // Edge Tabelle  
        try {
            await connection.execute(`DROP TABLE kg_edges CASCADE CONSTRAINTS`);
        } catch (e) {}

        await connection.execute(`
      CREATE TABLE kg_edges (
        edge_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        source_vertex_id VARCHAR2(50) NOT NULL,
        dest_vertex_id VARCHAR2(50) NOT NULL,
        edge_label VARCHAR2(100) NOT NULL,
        properties CLOB,
        CHECK (properties IS JSON),
        CONSTRAINT fk_source FOREIGN KEY (source_vertex_id) REFERENCES kg_vertices(vertex_id),
        CONSTRAINT fk_dest FOREIGN KEY (dest_vertex_id) REFERENCES kg_vertices(vertex_id)
      )
    `);

        console.log('✅ Tabellen erstellt\n');

        // 2. Füge Vertices ein
        console.log('🔸 Füge Vertices ein...');

        let vertexCount = 0;
        for (const node of nodes) {
            const vertexId = node.properties.id;
            const vertexType = node.label.toUpperCase();

            // Mapping speichern
            mgIdMapping[node.mgId] = vertexId;

            // Properties als JSON
            const propJson = JSON.stringify(node.properties);

            await connection.execute(
                `INSERT INTO kg_vertices (vertex_id, vertex_type, properties) 
         VALUES (:id, :type, :props)`,
                {
                    id: vertexId,
                    type: vertexType,
                    props: propJson
                }
            );

            vertexCount++;
            if (vertexCount % 50 === 0) {
                console.log(`   ${vertexCount} Vertices eingefügt...`);
            }
        }

        console.log(`✅ ${vertexCount} Vertices eingefügt\n`);

        // 3. Füge Edges ein
        console.log('🔗 Füge Edges ein...');

        let edgeCount = 0;
        for (const rel of relationships) {
            const sourceId = mgIdMapping[rel.fromMgId];
            const destId = mgIdMapping[rel.toMgId];

            if (!sourceId || !destId) continue;

            await connection.execute(
                `INSERT INTO kg_edges (source_vertex_id, dest_vertex_id, edge_label, properties) 
         VALUES (:source, :dest, :label, :props)`,
                {
                    source: sourceId,
                    dest: destId,
                    label: rel.relType,
                    props: '{}'
                }
            );

            edgeCount++;
        }

        console.log(`✅ ${edgeCount} Edges eingefügt\n`);

        // 4. Erstelle Property Graph
        console.log('🌐 Erstelle Property Graph Definition...');

        try {
            await connection.execute(`DROP PROPERTY GRAPH knowledge_graph CASCADE`);
        } catch (e) {}

        await connection.execute(`
      CREATE PROPERTY GRAPH knowledge_graph
        VERTEX TABLES (
          kg_vertices 
            KEY (vertex_id)
            LABEL person PROPERTIES (vertex_id, properties) WHERE vertex_type = 'PERSON'
            LABEL place PROPERTIES (vertex_id, properties) WHERE vertex_type = 'PLACE'
            LABEL work PROPERTIES (vertex_id, properties) WHERE vertex_type = 'WORK'
            LABEL award PROPERTIES (vertex_id, properties) WHERE vertex_type = 'AWARD'
            LABEL workplace PROPERTIES (vertex_id, properties) WHERE vertex_type = 'WORKPLACE'
            LABEL field PROPERTIES (vertex_id, properties) WHERE vertex_type = 'FIELD'
            LABEL occupation PROPERTIES (vertex_id, properties) WHERE vertex_type = 'OCCUPATION'
        )
        EDGE TABLES (
          kg_edges
            KEY (edge_id)
            SOURCE KEY (source_vertex_id) REFERENCES kg_vertices(vertex_id)
            DESTINATION KEY (dest_vertex_id) REFERENCES kg_vertices(vertex_id)
            LABEL advised WHERE edge_label = 'ADVISED'
            LABEL worked_at WHERE edge_label = 'WORKED_AT'
            LABEL born_in WHERE edge_label = 'BIRTH_IN'
            LABEL died_in WHERE edge_label = 'DIED_IN'
            LABEL created WHERE edge_label = 'CREATED'
            LABEL received WHERE edge_label = 'RECEIVED'
            LABEL works_in WHERE edge_label = 'WORKS_IN'
            LABEL has_occupation WHERE edge_label = 'HAS_OCCUPATION'
            LABEL influenced_by WHERE edge_label = 'INFLUENCED_BY'
            LABEL student_of WHERE edge_label = 'STUDENT_OF'
            LABEL relative_of WHERE edge_label = 'RELATIVE_OF'
            LABEL partner_of WHERE edge_label = 'PARTNER_OF'
            LABEL father_of WHERE edge_label = 'FATHER_OF'
            LABEL mother_of WHERE edge_label = 'MOTHER_OF'
            LABEL national_of WHERE edge_label = 'NATIONAL_OF'
            LABEL significant_person_for WHERE edge_label = 'SIGNIFICANT_PERSON_FOR'
            PROPERTIES (edge_id, properties)
        )
    `);

        await connection.commit();
        console.log('✅ Property Graph erfolgreich erstellt!\n');

        // 5. Test Query
        console.log('🔍 Teste Property Graph mit PGQL...');

        const testResult = await connection.execute(`
      SELECT v.vertex_id, v.vertex_type
      FROM GRAPH_TABLE (knowledge_graph
        MATCH (v)
        WHERE v.vertex_type = 'PERSON'
        COLUMNS (v.vertex_id, v.vertex_type)
      ) 
      FETCH FIRST 5 ROWS ONLY
    `);

        console.log('✅ Test erfolgreich - Beispiel Personen:');
        testResult.rows.forEach(row => {
            console.log(`   - ${row[0]} (${row[1]})`);
        });

    } catch (error) {
        console.error('❌ Import-Fehler:', error.message);
        console.error(error);
        if (connection) {
            await connection.rollback();
        }
    } finally {
        if (connection) await connection.close();
        await closeOraclePool();
    }
}

// Script ausführen
if (require.main === module) {
    const filename = process.argv[2] || 'memgraph-export.txt';

    console.log('🚀 Starte Oracle Property Graph Import...\n');

    importToOraclePropertyGraph(filename)
        .then(() => {
            console.log('\n✅ Import erfolgreich abgeschlossen!');
            console.log('\n📝 Hinweise:');
            console.log('   - Property Graph "knowledge_graph" wurde erstellt');
            console.log('   - Verwenden Sie PGQL oder SQL/PGQ für Abfragen');
            console.log('   - Der QueryTranslator wurde für Property Graph angepasst');
            process.exit(0);
        })
        .catch(error => {
            console.error('Fatal:', error);
            process.exit(1);
        });
}

module.exports = { importToOraclePropertyGraph };